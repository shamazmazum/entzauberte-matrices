(in-package :entzauberte-matrices)

(macrolet ((def-add (name)
             (multiple-value-bind (lisp-name fortran-name)
                 (wrapper-names name)
               `(defcfun (,lisp-name ,fortran-name) :void
                  (n    (:pointer :int))
                  (sa   :pointer)
                  (sx   :pointer)
                  (incx (:pointer :int))
                  (sy   :pointer)
                  (incy (:pointer :int))))))
  (def-add saxpy)
  (def-add daxpy)
  (def-add caxpy)
  (def-add zaxpy))

(macrolet ((def-add (name low-level-fn lisp-type foreign-type)
             (let ((complexp (listp lisp-type)))
               `(progn
                  (serapeum:-> ,name ((mat-or-vec ,lisp-type)
                                      (mat-or-vec ,lisp-type)
                                       ,lisp-type)
                               (values (smat-or-svec ,lisp-type)
                                       &optional))
                  (defun ,name (v1 v2 s)
                    (let ((v2 (copy-array v2))
                          (n  (array-total-size v1)))
                      (with-foreign-objects ((nptr    :int)
                                             (saptr   ,foreign-type ,(if complexp 2 1))
                                             (incxptr :int)
                                             (incyptr :int))
                        (setf (mem-ref nptr    :int) n
                              (mem-ref incxptr :int) 1
                              (mem-ref incyptr :int) 1
                              ,@(if complexp
                                    `((mem-aref saptr ,foreign-type 0)
                                      (realpart s)
                                      (mem-aref saptr ,foreign-type 1)
                                      (imagpart s))
                                    `((mem-ref saptr ,foreign-type) s)))
                        (with-array-pointers ((v1ptr v1)
                                              (v2ptr v2))
                          (,low-level-fn nptr saptr v1ptr incxptr v2ptr incyptr)))
                      v2))))))
  (def-add add-rs-unsafe %saxpy single-float :float)
  (def-add add-rd-unsafe %daxpy double-float :double)
  (def-add add-cs-unsafe %caxpy (complex single-float) :float)
  (def-add add-cd-unsafe %zaxpy (complex double-float) :double))

(serapeum:-> add ((mat-or-vec *) (mat-or-vec *) &optional number)
             (values (smat-or-svec *) &optional))
(defun add (m1 m2 &optional (s (coerce 1 (array-element-type m1))))
  "Compute \\(s m_1 + m_2\\) where \\(s\\) is a scalar and \\(m_1\\)
and \\(m_2\\) are two matrices of vectors.. By default \\(s\\) is
\\(1\\)."
  (unless (or (and (= (array-rank m1)
                      (array-rank m2) 2)
                   (= (array-dimension m1 0)
                      (array-dimension m2 0))
                   (= (array-dimension m1 1)
                      (array-dimension m2 1)))
              (and (= (array-rank m1)
                      (array-rank m2) 1)
                   (= (length m1) (length m2))))
    (error "Cannot add matrices: Incompatible dimensions"))
  (let ((t1 (array-element-type m1))
        (t2 (array-element-type m2)))
    (funcall
     (cond
       ((and (eq t1 'single-float)
             (eq t2 'single-float))
        #'add-rs-unsafe)
       ((and (eq t1 'double-float)
             (eq t2 'double-float))
        #'add-rd-unsafe)
       ((and (equalp t1 '(complex single-float))
             (equalp t2 '(complex single-float)))
        #'add-cs-unsafe)
       ((and (equalp t1 '(complex double-float))
             (equalp t2 '(complex double-float)))
        #'add-cd-unsafe)
       (t (error "Cannot add: incompatible element types: ~a and ~a" t1 t2)))
     m1 m2 s)))

(serapeum:-> sub ((mat-or-vec *) (mat-or-vec *))
             (values (smat-or-svec *) &optional))
(declaim (inline sub))
(defun sub (m1 m2)
  "Compute \\(m_1 - m_2\\). A special case of @c(add)."
  (add m2 m1 (coerce -1 (array-element-type m1))))
