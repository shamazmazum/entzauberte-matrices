(in-package :entzauberte-matrices)

(macrolet ((define-foreign-mult (name foreign-type)
             (let* ((name (symbol-name name))
                    (lisp-name (intern (format nil "%~a" name)))
                    (fortran-name (format nil "~a_" (string-downcase name))))
               `(defcfun (,lisp-name ,fortran-name) :void
                  (transa (:pointer :uint8))
                  (transb (:pointer :uint8))
                  (m      (:pointer :int))
                  (n      (:pointer :int))
                  (k      (:pointer :int))
                  (alpha  (:pointer ,foreign-type))
                  (a      :pointer)
                  (lda    (:pointer :int))
                  (b      :pointer)
                  (ldb    (:pointer :int))
                  (beta   (:pointer ,foreign-type))
                  (c      :pointer)
                  (ldc    (:pointer :int))))))
  ;; Real
  (define-foreign-mult sgemm :float)
  (define-foreign-mult dgemm :double)
  ;; Complex
  (define-foreign-mult cgemm :float)
  (define-foreign-mult zgemm :double))

(macrolet ((define-lisp-mult (high-level-name low-level-name lisp-type foreign-type)
             (let* ((complexp (and (listp lisp-type) (eq (first lisp-type) 'complex)))
                    (float-type (if complexp (second lisp-type))))
               `(progn
                  (serapeum:-> ,high-level-name ((simple-array ,lisp-type 2)
                                                 (simple-array ,lisp-type 2)
                                                 boolean boolean ,lisp-type)
                               (values (simple-array ,lisp-type 2) &optional))
                  (defun ,high-level-name (a b ta tb scale)
                    (let ((c (make-array (list (array-dimension a (if ta 1 0))
                                               (array-dimension b (if tb 0 1)))
                                         :element-type ',lisp-type)))
                      (with-array-pointers ((aptr (sb-ext:array-storage-vector a))
                                            (bptr (sb-ext:array-storage-vector b))
                                            (cptr (sb-ext:array-storage-vector c)))
                        (with-foreign-objects ((transa :char)
                                               (transb :char)
                                               (mptr   :int)
                                               (nptr   :int)
                                               (kptr   :int)
                                               (alpha  ,foreign-type ,@(if complexp '(2)))
                                               (lda    :int)
                                               (ldb    :int)
                                               (beta   ,foreign-type ,@(if complexp '(2)))
                                               (ldc    :int))
                          (let ((m (array-dimension b (if tb 0 1)))
                                (n (array-dimension a (if ta 1 0)))
                                (k (array-dimension b (if tb 1 0))))
                            (setf (mem-ref transa :uint8) (char-code (if tb #\t #\n))
                                  (mem-ref transb :uint8) (char-code (if ta #\t #\n))
                                  (mem-ref mptr :int) m
                                  (mem-ref nptr :int) n
                                  (mem-ref kptr :int) k
                                  ,@(if complexp
                                        `((mem-aref alpha ,foreign-type 0)
                                          (realpart scale)
                                          (mem-aref alpha ,foreign-type 1)
                                          (imagpart scale))
                                        `((mem-ref alpha ,foreign-type) scale))
                                  (mem-ref lda :int) (if tb k m)
                                  (mem-ref ldb :int) (if ta n k)
                                  ,@(if complexp
                                        `((mem-aref beta ,foreign-type 0)
                                          (coerce 0 ',float-type)
                                          (mem-aref beta ,foreign-type 1)
                                          (coerce 0 ',float-type))
                                        `((mem-ref beta ,foreign-type)
                                          (coerce 0 ',lisp-type)))
                                  (mem-ref ldc :int) m)
                            (,low-level-name
                             transa transb mptr nptr kptr alpha
                             bptr lda aptr ldb beta cptr ldc))))
                      c))))))
  (define-lisp-mult mult-rs-unsafe %sgemm single-float :float)
  (define-lisp-mult mult-rd-unsafe %dgemm double-float :double)
  (define-lisp-mult mult-cs-unsafe %cgemm (complex single-float) :float)
  (define-lisp-mult mult-cd-unsafe %zgemm (complex double-float) :double))

(declaim (inline mult))
(defun mult (a b &key ta tb scale)
  (unless (= (array-dimension a (if ta 0 1))
             (array-dimension b (if tb 1 0)))
    (error "Cannot multiply: matrices have incompatible dimensions"))
  (let* ((t1 (array-element-type a))
         (t2 (array-element-type b))
         (scale (if scale scale (coerce 1 t1))))
    (funcall
     (cond
       ((and (eq t1 'single-float)
             (eq t2 'single-float))
        #'mult-rs-unsafe)
       ((and (eq t1 'double-float)
             (eq t2 'double-float))
        #'mult-rd-unsafe)
       ((and (equalp t1 '(complex single-float))
             (equalp t2 '(complex single-float)))
        #'mult-cs-unsafe)
       ((and (equalp t1 '(complex double-float))
             (equalp t2 '(complex double-float)))
        #'mult-cd-unsafe)
       (t (error "Cannot multiply: incompatible element types: ~a and ~a" t1 t2)))
   a b ta tb scale)))
