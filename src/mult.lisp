(in-package :entzauberte-matrices)

(defcfun (%sgemm "sgemm_") :void
  (transa (:pointer :uint8))
  (transb (:pointer :uint8))
  (m      (:pointer :int))
  (n      (:pointer :int))
  (k      (:pointer :int))
  (alpha  (:pointer :float))
  (a      :pointer)
  (lda    (:pointer :int))
  (b      :pointer)
  (ldb    (:pointer :int))
  (beta   (:pointer :float))
  (c      :pointer)
  (ldc    (:pointer :int)))

(serapeum:-> mult ((simple-array single-float 2)
                   (simple-array single-float 2)
                   &key (:ta boolean) (:tb boolean) (:scale single-float))
             (values (simple-array single-float 2) &optional))
(defun mult (a b &key ta tb (scale 1.0))
  (assert (= (if ta (array-dimension a 0) (array-dimension a 1))
             (if tb (array-dimension b 1) (array-dimension b 0))))
  (let ((c (make-array (list (if ta (array-dimension a 1) (array-dimension a 0))
                             (if tb (array-dimension b 0) (array-dimension b 1)))
                       :element-type 'single-float)))
    (with-array-pointers ((aptr (sb-ext:array-storage-vector a))
                          (bptr (sb-ext:array-storage-vector b))
                          (cptr (sb-ext:array-storage-vector c)))
      (with-foreign-objects ((transa :char)
                             (transb :char)
                             (mptr   :int)
                             (nptr   :int)
                             (kptr   :int)
                             (alpha  :float)
                             (lda    :int)
                             (ldb    :int)
                             (beta   :float)
                             (ldc    :int))
        (let ((m (if tb (array-dimension b 0) (array-dimension b 1)))
              (n (if ta (array-dimension a 1) (array-dimension a 0)))
              (k (if tb (array-dimension b 1) (array-dimension b 0))))
          (setf (mem-ref transa :uint8) (char-code (if tb #\t #\n))
                (mem-ref transb :uint8) (char-code (if ta #\t #\n))
                (mem-ref mptr :int) m
                (mem-ref nptr :int) n
                (mem-ref kptr :int) k
                (mem-ref alpha :float) scale
                (mem-ref lda :int) (if tb k m)
                (mem-ref ldb :int) (if ta n k)
                (mem-ref beta :float) 0.0
                (mem-ref ldc :int) m)
          (%sgemm transa transb mptr nptr kptr alpha bptr lda aptr ldb beta cptr ldc))))
    c))
