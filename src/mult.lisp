(in-package :entzauberte-matrices)

(defcfun (%sgemm "sgemm_") :void
  (transa (:pointer :uint8))
  (transb (:pointer :uint8))
  (m      (:pointer :int))
  (n      (:pointer :int))
  (k      (:pointer :int))
  (alpha  (:pointer :float))
  (a      :pointer)
  (lda    (:pointer :int))
  (b      :pointer)
  (ldb    (:pointer :int))
  (beta   (:pointer :float))
  (c      :pointer)
  (ldc    (:pointer :int)))

(serapeum:-> mult-rs-unsafe ((simple-array single-float 2)
                             (simple-array single-float 2)
                             boolean boolean single-float)
             (values (simple-array single-float 2) &optional))
(defun mult-rs-unsafe (a b ta tb scale)
  (let ((c (make-array (list (array-dimension a (if ta 1 0))
                             (array-dimension b (if tb 0 1)))
                       :element-type 'single-float)))
    (with-array-pointers ((aptr (sb-ext:array-storage-vector a))
                          (bptr (sb-ext:array-storage-vector b))
                          (cptr (sb-ext:array-storage-vector c)))
      (with-foreign-objects ((transa :char)
                             (transb :char)
                             (mptr   :int)
                             (nptr   :int)
                             (kptr   :int)
                             (alpha  :float)
                             (lda    :int)
                             (ldb    :int)
                             (beta   :float)
                             (ldc    :int))
        (let ((m (array-dimension b (if tb 0 1)))
              (n (array-dimension a (if ta 1 0)))
              (k (array-dimension b (if tb 1 0))))
          (setf (mem-ref transa :uint8) (char-code (if tb #\t #\n))
                (mem-ref transb :uint8) (char-code (if ta #\t #\n))
                (mem-ref mptr :int) m
                (mem-ref nptr :int) n
                (mem-ref kptr :int) k
                (mem-ref alpha :float) scale
                (mem-ref lda :int) (if tb k m)
                (mem-ref ldb :int) (if ta n k)
                (mem-ref beta :float) 0.0
                (mem-ref ldc :int) m)
          (%sgemm transa transb mptr nptr kptr alpha bptr lda aptr ldb beta cptr ldc))))
    c))

(declaim (inline mult))
(defun mult (a b &key ta tb (scale 1.0))
  (unless (= (array-dimension a (if ta 0 1))
             (array-dimension b (if tb 1 0)))
    (error "Cannot multiply: matrices have incompatible dimensions"))
  (let ((t1 (array-element-type a))
        (t2 (array-element-type b)))
    (funcall
     (cond
       ((and (eq t1 'single-float)
             (eq t2 'single-float))
        #'mult-rs-unsafe)
       (t (error "Cannot multiply: incompatible element types: ~a and ~a" t1 t2)))
   a b ta tb scale)))
